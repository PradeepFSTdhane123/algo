---
id: Maximum-Product-Subarray-leetcode-152
title: Maximum product Subarray.
sidebar_label: Leetcode 152.
tags: [Leetcode, Array, DSA,Maximum product Subarray ]
description: Given an integer array nums, find a 
subarray
 that has the largest product, and return the product.

The test cases are generated so that the answer will fit in a 32-bit integer.
---

## 53. Maximum subarray.
**Description**: 
 The problem requires finding the maximum product of a contiguous subarray within a given integer array nums. This is a common problem that can be efficiently solved using dynamic programming principles.

### Example 1:

**Input:**
Input:nums = [2, 3, -2, 4]
Output: 6
Explanation: 

**Explanation:** 
- he contiguous subarrays and their products are:
[2] → Product = 2
[3] → Product = 3
[2, 3] → Product = 6
[-2] → Product = -2
[-2, 4] → Product = -8
[3, -2] → Product = -6
[2, 3, -2] → Product = -6
[2, 3, -2, 4] → Product = -24
[4] → Product = 4
The maximum product of any contiguous subarray is 6, obtained from the subarray [2, 3].


 **C++ Code**:
```cpp
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        // Initialize result, current min, and current max
        int res = nums[0];
        int curMin = 1, curMax = 1;
        
        // Iterate over each number in the array
        for(int i = 0; i < nums.size(); i++) {
            int n = nums[i];
                
            // Store current max product for calculation
            int tmp = curMax * n;
            // Update current max
            curMax = max(max(n * curMax, n * curMin), n);
            // Update current min
            curMin = min(min(tmp, n * curMin), n);
            // Update the overall maximum product found
            res = max(res, curMax);
        }
        
        return res; // Return the maximum product
    }
};

```
### Approach and code explanation ###
**Algorithm used:**
-The algorithm utilizes a dynamic approach by maintaining both the maximum and minimum products encountered so far. The minimum product is essential because a negative number multiplied by a negative minimum can become the maximum product.

**2. Iterating Through the Array:**
**Initialization:**

- res to store the maximum product found, initialized to the first element.
curMin and curMax to store the current minimum and maximum products ending at the current position.
**Iterate through the array:**

- For each element, calculate the temporary maximum product using curMax.
- 
**Update curMax to be the maximum of:**

- The current number itself.
The product of the current number with the previous maximum product.
The product of the current number with the previous minimum product (to handle cases with negative numbers).
Update curMin similarly, taking care to keep track of the minimum product.
Update res with the maximum of res and curMax.
**Return the result:**

- The maximum product found in any contiguous subarray.

### Example with explanation ###
- Initialization:

- Start by initializing:
res = nums[0] → This will hold the maximum product found so far. In this case, res = 2.
curMin = 1 → This variable will keep track of the current minimum product (to handle negative numbers).
curMax = 1 → This variable will keep track of the current maximum product.
Iterate Through the Array:

- Loop through each element in nums.
Step-by-Step Execution
Iteration 1 (i = 0, n = 2):

Before Update: curMin = 1, curMax = 1
Calculate temporary maximum:
tmp = curMax * n = 1 * 2 = 2
Update curMax:
curMax = max(max(2 * 1, 2 * 1), 2) = max(2, 2, 2) = 2
Update curMin:
curMin = min(min(2, 2 * 1), 2) = min(2, 2, 2) = 2
Update res:
res = max(2, 2) = 2
Iteration 2 (i = 1, n = 3):

- Before Update: curMin = 2, curMax = 2
Calculate temporary maximum:
tmp = curMax * n = 2 * 3 = 6
Update curMax:
curMax = max(max(3 * 2, 3 * 2), 3) = max(6, 6, 3) = 6
Update curMin:
curMin = min(min(6, 3 * 2), 3) = min(6, 6, 3) = 3
Update res:
res = max(2, 6) = 6
Iteration 3 (i = 2, n = -2):

- Before Update: curMin = 3, curMax = 6
Calculate temporary maximum:
tmp = curMax * n = 6 * -2 = -12
Update curMax:
curMax = max(max(-2 * 6, -2 * 3), -2) = max(-12, -6, -2) = -2
Update curMin:
curMin = min(min(-12, -2 * 3), -2) = min(-12, -6, -2) = -12
Update res:
res = max(6, -2) = 6
Iteration 4 (i = 3, n = 4):

Before Update: curMin = -12, curMax = -2
Calculate temporary maximum:
tmp = curMax * n = -2 * 4 = -8
Update curMax:
curMax = max(max(4 * -2, 4 * -12), 4) = max(-8, -48, 4) = 4
- Update curMin:
curMin = min(min(-8, 4 * -12), 4) = min(-8, -48, 4) = -48
- Update res:
res = max(6, 4) = 6

### complexcity
#### Time Complexity:
Reason: The algorithm iterates through the array exactly once. For each element, it performs a constant amount of work (calculating the maximum of two values). Thus, if n is the number of elements in the array, the total time complexity is linear: O(n).

#### Space complexity: #### 
-Reason: The algorithm uses a fixed amount of extra space regardless of the input size. It only maintains a few integer variables (curr and result), and does not use any additional data structures that grow with the input. Therefore, the space complexity is constant: O(1).